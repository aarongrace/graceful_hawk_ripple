	USE	"hawk.h"	
	USE	"stdio.h"
	USE	"stdlib.h"
	USE	"common.h"

; canvas object
; all funcs in this Module use RF for address of the canvas

; each pixel is a word
PX_SIZE	= 4
PX_IN_COLUMN = 64


CANVAS_SIZE = 1792


	INT	INIT_CANVAS
ARSIZE=4 ;||||||||||||||||||||||||||||||||||||||||||||||
INIT_CANVAS:
	C_S

	; each number on the canvas is a bit
	; though it is more storage efficient to use words
	; it is much easier to manipulate this way

	; the canvas is a two-dimensional array with varying lengths
	LIL	R3,C_ROWS
	SL	R3,2
	TOSUBR	MALLOC
	SETCOM	R4,R3,CANVAS
	
	MOVE	RA,R3	;RA is used as pointer to canvas obj
	LIS	R8,0	; R8=curr_row
	LIL	R9,C_UPPER_COLS ;R9 = cols to allocate
	SL	R9,2
IC_LOOP:
	MOVE	R3,R9	;allocate cols*4 bytes
	TOSUBR	MALLOC
	STORES	R3,RA	; store the pointer to the row

	ADDSI	R8,1
	; if R8 is 8, switch to col numbers for monitor
	CMPI	R8,8
	BNE	IC_NOT_8
	LIL	R9,C_LOWER_COLS
	SL	R9,2
IC_NOT_8:
	ADDSI	RA,4
	CMPI	R8,C_ROWS
	BLT	IC_LOOP

	TOSUBR	FILL_CANVAS_S
	R_S


	INT	DRAW_ON_CANVAS
ARSIZE=4
DRAW_ON_CANVAS:
	C_S
	; takes R3=hex to draw, R4=x,R5=y
	TESTR	R5
	BLT	DCANVAS_MONITOR
	
	TESTR	R4
	BLT	DCANVAS_REGISTER
	TOSUBR	DRAW_ON_MEMORY

DCANVAS_REGISTER:
	TOSUBR	TO_REGISTER_COORDS

DCANVAS_MONITOR:
	TOSUBR	TO_MONITOR_COORDS
DCANVAS_RETURN:
	R_S

	
MEMORY_ADD_W=8
MEMORY_BITS=8
ARSIZE=4
DRAW_ON_MEMORY:
	; takes R3=hex to draw, R4=x,R5=y

	CMPI	R4, MEMORY_ADD_W	; if (x < memory_add_w) return
	BLT	DMEM_RETURN

	CMPI	R4, MEMORY_ADD_W + MEMORY_BITS
	BGE	DMEM_RETURN

	ADDSI	R5,-C_UPPER_ROWS	; y = 8 -y
	NEG	R5,R5
	SL	R5,2


	LOADCOM	R7,CANVAS	; the the right row into R7
	ADD	R7,R7,R5
	LOADS	R7,R7

	ADDI	R4,R4,-MEMORY_ADD_W+C_REG_BITS
	SL	R4,2
	ADD	R7,R7,R4
	
	STORES	R3,R7

DMEM_RETURN:
	BR	DCANVAS_RETURN


ARSIZE=4
TO_REGISTER_COORDS:
	; takes R3=hex to draw, R4=x,R5=y
	BR	DCANVAS_RETURN


ARSIZE=4
TO_MONITOR_COORDS:
	; takes R3=hex to draw, R4=x,R5=y
	BR	DCANVAS_RETURN


ARSIZE=4  ;|||||||||||||||||||||||||||||||||||||||||||||
FILL_CANVAS_S:
	; set a word in the canvas array
	C_S
	LOADCOM	RF,CANVAS
	LOADCOM	R3,FILL_S_FIRST_LETTER

;---------------------------------rows loop
	LIS	R8,0	; R8=curr_row
	LIL	R9,C_UPPER_COLS ;R9 = cols to fill
FCS_ROWS_LOOP:
	LOADS	RA,RF	;RA is used as pointer to canvas row
;------------------one row loop
	LIS	R7,0	; R7=curr_col
	LIS	R5,0	; R5=control for break rhthm
FCS_FILL_EACH_COLUMN:
	STORES	R3,RA	; store the char to the col

	ADDSI	R3,1 ;increment the char
	CMPI	R3,15
	BLE	FCS_R3_NOT_15
	TESTR	R5	; if R5 is 1, set R3 to 0 instead of 1 to break the rhythm
	BEQ	FCS_R5_0
	LIS	R5,0
	LIS	R3,15
	BR	FCS_R3_NOT_15
FCS_R5_0:
	LIS	R5,1
	LIS	R3,0

FCS_R3_NOT_15:
	ADDSI	R7,1
	ADDSI	RA,4
	CMP	R7,R9
	BLT	FCS_FILL_EACH_COLUMN
;----------------
	ADDSI	R8,1 

	CMPI	R8,8	 ; if R8 is 8, switch to col numbers for monitor
	BNE	FCS_NOT_8
	LIL	R9,C_LOWER_COLS

FCS_NOT_8:
	ADDSI	RF,4	; moving to next row
	CMPI	R8,C_ROWS
	BLT	FCS_ROWS_LOOP
	R_S
END
;-----------------------------------for testing
	INT MAIN
	S	DRAW_ON_CANVAS
MAIN:
	LIS	R3,F
	LIS	R4,3
	LIS	R5,3
	TOSUBR DRAW_ON_CANVAS

	END
