	USE	"hawk.h"	
	USE	"stdio.h"
	USE	"stdlib.h"
	USE	"common.h"
; canvas object
	INT	DEBUG	

; address of two blocks of words to be loaded into reg and mem
; leaving one word each as a cushion
	COMMON	REG_WORDS, 66
	COMMON	MEM_WORDS, 34
;	COMMON	CANVAS_WORDS, 100
UPPER_WORDS=24	; there 8 * 3 words for the register and the memory


MONITOR_START = 768

MACRO COL_BREAK_CHECK =comp, =start_x, check
	CMPI	RA,comp
	BNE	check
	LIL	R3,start_x
	MOVE	R4,RB
	LIL	R1,PUTAT
	JSRS	R1,R1
	BR	RM_END_COL_BREAK_CHECK
ENDMAC

ARSIZE=4
RECREATE_MONITOR:; |||||||||||||||||||||||||||||
	C_S
	LOADCOM	RF,CANVAS
	LIL	R3,C_UPPER_ROWS
	SL	R3,2
	ADD	RF,RF,R3 ;set RF to start of monitor rows

	LIS	RB,0	;row
;-------------------monitor scope--------------------
RM_ROW_LOOP:
	LOADS	RC,RF
;---------------------row scope-----
	LIS	RA,0	; bit
	LIL	R3,M_LEFT_S	 ; where reg nums start
	MOVE	R4,RB
	TOSUBR	PUTAT
RM_PRINT_ROW:	
	; loading curr int into R3 and converting it from int to char
	LOADS	R3,RC
	CMPI	R3,10
	BLT	RM_LOWER_THAN_10
	; 10 plus "0" is ":", which is 7 away from "A"
	ADDI	R3,R3,7
RM_LOWER_THAN_10:
	ADDI	R3,R3,"0"
	TOSUBR	PUTCHAR

	; after printing, increment vars
	ADDSI	RC,4
	ADDSI	RA,1

;	CMPI	RA,8
;	BNE	RM_END_COL_BREAK_CHECK
;	LIL	R3,M_MID_COL
;	MOVE	R4,RB
;	LIL	R1,PUTAT
;	JSRS	R1,R1
;	BR	RM_END_COL_BREAK_CHECK
;
	COL_BREAK_CHECK M_LEFT_W, M_MID_S, MID_CHECK
MID_CHECK:
	COL_BREAK_CHECK M_LEFT_W + M_MID_W, M_THIRD_S, THIRD_CHECK
THIRD_CHECK:
	COL_BREAK_CHECK M_LEFT_W + M_MID_W + M_THIRD_W, M_RIGHT_S, RM_END_COL_BREAK_CHECK
;	COL_BREAK_CHECK 16, M_MID_COL
;	COL_BREAK_CHECK 8, M_MID_COL
;	COL_BREAK_CHECK M_MID_COL + 8, M_THIRD_COL
;	COL_BREAK_CHECK M_THIRD_COL + 8, M_RIGHT_COL

RM_END_COL_BREAK_CHECK:
	CMPI	RA,C_LOWER_COLS
	BLT	RM_PRINT_ROW

	ADDSI	RF,4
	ADDSI	RB,1
	CMPI	RB,8
	BLT	RM_ROW_LOOP
	R_S




ARSIZE=4
CREATE_REG_MEM_WORDS:	;||||||||||||||||||||||||||||||||||||
; turns the canvas array into words
; uses 	RC=canvas pointer, RA=bit, RB=row, RE=column
;	R7, temp_word, R6, pointer to word common
	C_S
	LOADCOM	RF,CANVAS	; pointer to canvas row
	LIL	R5,REG_WORDS	;pointer to curr reg word
	LIL	R6,MEM_WORDS	;pointer to curr mem word

	LIS	RB,0	; horizontal row
CCW_ROW_LP:;-----------------horizontal row (three 8s) scope
	LOADS	RC,RF	; curr row in canvas
	LIS	RE,0	; the column
CCW_WORD_LP:;-----------------------column scope 
	LIS	RA,0	; bit
	LIS	R7,0	; temp word
CCW_ADD_BIT:	;------------word scope
	; loading curr int into R3 and shift it into place
	LOADS	R3,RC	; curr int
	MOVE	R4,RA	; R4 is used to shift the right amount of bits
CCW_SHIFT_LP:
	TESTR	R4	
	BZS	CCW_SHIFT_LP_QT
	SL	R3,4
	ADDSI	R4,-1
	BR	CCW_SHIFT_LP
CCW_SHIFT_LP_QT:
	OR	R7,R3	; combining the bit from array to the temp word

	ADDSI	RC,4 ; moving to next bit
	ADDSI	RA,1

	CMPI	RA,8
	BLT	CCW_ADD_BIT
;------------------end of word word scope, deciding column
	CMPI	RE,2
	BEQ	CCW_STORE_MEM
CCW_STORE_REG:
	STORES	R7,R5	;storing into REG array
	ADDSI	R5,4
	ADDSI	RE,1	;incre column
	BR	CCW_WORD_LP
CCW_STORE_MEM:
	STORES	R7,R6	;storing into MEM array
;------------------------end row scope
	ADDSI	R6,4
	ADDSI	RF,4

	ADDSI	RB,1
	CMPI	RB,C_UPPER_ROWS
	BLT	CCW_ROW_LP
;---------------------------------------------end canvas scope
	R_S


RECREATE_MEMORY: ;||||||||||||||||||||||||||||||||||||||||
	C_S
	; set R6 to the row of MEMD
	LIL	R6,MEM_WORDS
	LIL	R5,MEMD_START

	; RB=row
	LIS	RB,0
RMEM_ROW_LOOP:
	; loading the word to be displayed into R3
	LOADS	R3,R6
	STORES	R3,R5
	
	ADDSI	R6,4
	ADDSI	R5,4

	ADDSI	RB,1
	CMPI	RB,8
	BLT	RMEM_ROW_LOOP
	TOSUBR  RESTORE_RETURN_ROW
	R_S


;this align directive is crucial
	ALIGN	4
EXECUTE_TEMPLATE:
	JSRS	R1, R1
	ALIGN	4

ARSIZE=0
RESTORE_RETURN_ROW:
	LIL	R3, EXECUTE_TEMPLATE	;the address that holds the template
	LOADS	R3, R3	;loading the first line of the template into R5

	LIL	R6, MEMD_RETURN	; MEMD_END, where the loop should be 

	LOADS	R4, R6		;R8 contains current contents of command row
	LIW	R5, #FFFF0000
	AND	R4, R5		; getting digits 5-8 of current contents
	OR	R3, R4		; combining with the command template
	STORES	R3,R6
	JUMPS	R1

MACRO LOAD_R reg 
	LOADS	reg,R1
	ADDSI	R1,4
ENDMAC

ARSIZE=4
RECREATE_REGISTERS:
; recreating the register, this subr does not end conventionally
; it jumps directly to MEMD_RETURN, which then goes to program cycle
	; set R6 to the row of MEMD
	LIL	R1,REG_WORDS
	LOAD_R R3
	LOAD_R R4
	LOAD_R R5
	LOAD_R R6
	LOAD_R R7
	LOAD_R R8
	LOAD_R R9
	LOAD_R R10
	LOAD_R R11
	LOAD_R R12
	LOAD_R R13
	LOAD_R R14
	LOAD_R R15

	; loading the word to be displayed into R3
	LOADCOM	R1,PROGRAM_CYCLE_AD
	LIL	R2,MEMD_RETURN
	JUMPS	R2

ARSIZE = 4;|||||||||||||||||||||||||||||||||||||||
FREE_CANVAS: 
;after changing the canvas into words, there is no need to move them
	C_S
	LOADCOM	R8,CANVAS

	LIS	R9,0
FC_LP:
	LOADS	R3,R8
	TOSUBR	FREE
	ADDSI	R8,4

	ADDSI	R9,1
	CMPI	R9,C_ROWS
	BLT	FC_LP

	LOADCOM	R3,CANVAS
	TOSUBR	FREE
	R_S

	INT	DISPLAY_CANVAS
DISPLAY_CANVAS:; |||||||||||||||||||||||||||||||||||||
; this subr has no AR and directly jumps back to the program cycle

	TOSUBR	RECREATE_MONITOR	;recreate hawk monitor
	TOSUBR	CREATE_REG_MEM_WORDS
	TOSUBR	FREE_CANVAS
	TOSUBR	RECREATE_MEMORY		 ;recreate the mem 

DEBUG:
	TOSUBR	RECREATE_REGISTERS	 ;recreate the reg

	END
	


